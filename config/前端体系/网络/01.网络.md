# é€šä¿¡åè®®

## SSE

### æ¦‚å¿µ

SSEå…¨ç§°**Server-Sent-Events**,æœåŠ¡ç«¯æ¨é€äº‹ä»¶ï¼Œæ˜¯HTML5æä¾›çš„ä¸€ç§**å•å·¥é€šä¿¡**ï¼Œç”±**æœåŠ¡ç«¯**å‘**å®¢æˆ·ç«¯**å‘èµ·é€šä¿¡ã€‚

### åˆæ­¥å®ç°

```tsx
// æœåŠ¡ç«¯
import express from 'express'
import cors from 'cors'

const app = express()
app.use(cors())

app.get('/sse', (req, res) => {
	res.setHeaders('Content-Type', 'text/event-stream')
	res.setHeader('Connection', 'keep-alive') // ä¿æŒé•¿è¿æ¥
	res.flushHeaders()
	
	res.write(`data: ${Math.random()}\n\n`)
})

app.listen(3000, () => {
	console.log('server is running at http://localhost:3000')
})

// å®¢æˆ·ç«¯

const sse= new EventSource('http://localhost:3000/sse')

sse.addEventListener('message', (event) => {
	console.log(event.data)
})
```

<aside>
ğŸ’¡

sseæ‰€ç›‘å¬çš„äº‹ä»¶åç§°å¯ä»¥æ”¹å˜ï¼Œåœ¨æœåŠ¡ç«¯ä¸­ä½¿ç”¨`res.write(`event: random`)` ä½¿ç›‘å¬çš„äº‹ä»¶æ”¹ä¸ºrandom

</aside>

### postå®ç°

- åŸç”Ÿå®ç°ï¼Œä¸æ”¯æŒè‡ªåŠ¨é‡è¿

```tsx
// æœåŠ¡ç«¯
import express from 'express'
import cors from 'cors'

const app = express()
app.use(cors())

app.post('/sse', (req, res) => {
	res.setHeaders('Content-Type', 'text/event-stream')
	res.setHeader('Connection', 'keep-alive') // ä¿æŒé•¿è¿æ¥
	res.flushHeaders()
	
	res.write(`data: ${Math.random()}\n\n`)
})

app.listen(3000, () => {
	console.log('server is running at http://localhost:3000')
})

// å®¢æˆ·ç«¯åªèƒ½ä½¿ç”¨fetch
async function startSSE() {
	const res = await fetch('http://localhost:3000/sse', {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json'
		},
		body: JSON.stringify({
			message: 'Hello, world!'
		})
	})
	// è·å–åˆ°çš„æ•°æ®æ ¼å¼ä¸ºUnit8Array,å¯ä»¥ä½¿ç”¨String.fromCharCode()è¯»å–
	const reader = res.body?.getReader()
	const arr: string[] = []
	while (true) {
		const { done, value } = await reader!.read()
		if (done) break
		const decoder = new TextDecoder()
		const valueStr = decoder.decode(value)
		const data = valueStr
			.split('\n')
			.filter(item => item !== '')
			.map(item => item.startsWith('data:') && item.split(':')[1])
			.join('')
			.split('')
		arr.push(...data)
		app.innerHTML += arr.shift()
	}
}

startSSE()
```

- `@microsoft/fetch-event-source`

```tsx
import { fetchEventSource } from '@microsoft/fetch-event-source'
fetchEventSource('http://localhost:3000/sse', {
	method: 'POST',
	headers: {
		'Content-Type': 'application/json'
	},
	body: JSON.stringify({
		message: 'Hello, world!'
	}),
	onmessage(event) {
		console.log(event.data)
	}
})
```

### åº”ç”¨åœºæ™¯

- AIå¯¹è¯

```tsx
import express from "express";
import { ChatOpenAI } from "@langchain/openai";
import { API_KEY } from "./config/env.js";
import { BufferMemory } from "langchain/memory";
import { PromptTemplate } from "@langchain/core/prompts";

const router = express.Router();

const model = new ChatOpenAI({
  model: "deepseek-chat",
  apiKey: API_KEY,
  temperature: 1.3,
  // å¼€å¯æµå¼è¾“å‡º
  streaming: true,
  configuration: {
    baseURL: "https://api.deepseek.com",
  },
});
// åˆ›å»ºè®°å¿†èƒ½åŠ›
const memory = new BufferMemory({
  // è¿”å›æ¶ˆæ¯
  returnMessages: true,
  // è®°å¿†é”®
  memoryKey: "chat_history",
  // è¾“å…¥é”®(æˆ‘ä»¬çš„é—®é¢˜)
  inputKey: "input",
});

// åˆ›å»ºæç¤ºè¯
const prompt = new PromptTemplate({
  template: `
        ä½ æ˜¯ä¸€ä¸ªé«˜çº§å‰ç«¯ä¸“ä¸šï¼Œç²¾é€šå„ç§æ¡†æ¶æºç ï¼Œå¯¹å‰ç«¯å·¥ç¨‹åŒ–æœ‰å¤§é‡å®è·µ
        å¯¹è¯å†…å®¹:
        {chat_history}
        ç”¨æˆ·çš„é—®é¢˜:
        {input}
        ä½ çš„å›ç­”:
    `,
  inputVariables: ["input", "chat_history"],
});

router.post("/chat", async (req, res) => {
  try {
    // è®¾ç½®SSEå“åº”å¤´
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.flushHeaders();

    const { message } = req.body;
    const history = await memory.loadMemoryVariables({});
    const chatHistory = history.chat_history || [];
    const formattedPrompt = await prompt.format({
      input: message,
      chat_history: chatHistory,
    });

    const result = await model.stream(formattedPrompt);

    for await (const chunk of result) {
      res.write(chunk.content);
    }

    // ä¿å­˜å®Œæ•´çš„å¯¹è¯åˆ°å†…å­˜
    await memory.saveContext({ input: message }, { output: formattedPrompt });
  } catch (error) {
    console.error("Stream error:", error);
  }
});

// å®¢æˆ·ç«¯
const startSSE = async (message) => {
  if (!message) return;
  try {
    const response = await fetch("http://localhost:3000/api/chat", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ message }),
    });
    const reader = response.body.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = new TextDecoder().decode(value);
      chat.innerHTML += chunk;
    }
  } catch (error) {
    console.log(error);
  }
};
sendButton.addEventListener("click", () => {
  const message = messageInput.value;
  startSSE(message);
});
```

- RAGæ•°æ®åº“æ£€ç´¢(ç»“åˆtypeorm)

```tsx
import express from "express";
import { ChatOpenAI } from "@langchain/openai";
import { API_KEY } from "./config/env.js";
import { PromptTemplate } from "@langchain/core/prompts";
import { SqlDatabase } from "langchain/sql_db";
import { dataSource } from "./sql.js";
import { createSqlQueryChain } from "langchain/chains/sql_db";
import { RunnableSequence } from "@langchain/core/runnables";
import { StringOutputParser } from "@langchain/core/output_parsers";

const router = express.Router();

await dataSource.initialize();
const db = await SqlDatabase.fromDataSourceParams({
  appDataSource: dataSource,
});

const model = new ChatOpenAI({
  model: "deepseek-chat",
  apiKey: API_KEY,
  temperature: 1.3,
  streaming: true,
  configuration: {
    baseURL: "https://api.deepseek.com",
  },
});

// åˆ›å»ºæç¤ºè¯
const prompt = new PromptTemplate({
  template: `
        ä½ æ˜¯ä¸€ä¸ªsqlæŸ¥è¯¢ä¸“å®¶ï¼Œè¯·æ ¹æ®ç”¨æˆ·çš„é—®é¢˜ç”Ÿæˆä¸€ä¸ªsqlè¯­å¥
		è¯·æ ¡éªŒsqlè¯­å¥æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœæ­£ç¡®è¯·è¿”å›sqlè¯­å¥ï¼Œå¦‚æœé”™è¯¯è¯·è¿”å›é”™è¯¯åŸå› 
		- ä½¿ç”¨ NOT IN ä¸ NULL å€¼
		- æ ‡è¯†ç¬¦æ˜¯å¦æ­£ç¡®å¼•ç”¨
		- å‡½æ•°æ˜¯å¦æ­£ç¡®ä½¿ç”¨
		- æ•°æ®ç±»å‹æ˜¯å¦åŒ¹é…
		- é¿å…ä½¿ç”¨å­æŸ¥è¯¢

		å¦‚æœä»¥ä¸ŠæŸ¥è¯¢é”™è¯¯ï¼Œè¯·é‡å†™æŸ¥è¯¢,å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œè¿”å›åŸå§‹æŸ¥è¯¢

		åªè¿”å›sqlè¯­å¥ï¼Œä¸è¦è¿”å›ä»»ä½•å…¶ä»–å†…å®¹

		åŸå§‹æŸ¥è¯¢ {query}
    `,
  inputVariables: ["query"],
});

const chain = await createSqlQueryChain({
  llm: model,
  db,
  dialect: "mysql",
});

const validateChain = prompt.pipe(model).pipe(new StringOutputParser());

const fullChain = RunnableSequence.from([
  {
    query: async (input) => {
      const result = await chain.invoke(input);
      return result;
    },
  },
  validateChain,
]);

router.post("/sql", async (req, res) => {
  const { query } = req.body;
  const sql = await fullChain.invoke({ question: query });
  const result = await db.run(sql);
  res.json(result);
});

export default router;
```